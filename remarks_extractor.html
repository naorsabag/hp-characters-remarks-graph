<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>HP Character Remarks Extractor</title>
  <style>
    body {
      font-family: sans-serif;
      margin: 20px;
    }
    #progress {
      font-weight: bold;
      margin-bottom: 10px;
    }
    pre {
      background: #f4f4f4;
      padding: 10px;
      border-radius: 6px;
      max-height: 400px;
      overflow: auto;
    }
  </style>
</head>
<body>
  <h1>Harry Potter Character Remarks Extractor</h1>

  <div style="margin-bottom: 20px; padding: 15px; border: 1px solid #ddd; border-radius: 6px; background-color: #f9f9f9;">
    <label for="apiKeyInput" style="display: block; margin-bottom: 8px; font-weight: bold;">OpenAI API Key:</label>
    <input
      type="password"
      id="apiKeyInput"
      placeholder="Enter your OpenAI API key (sk-...)"
      style="width: 100%; max-width: 500px; padding: 8px; border: 1px solid #ccc; border-radius: 4px; margin-bottom: 8px;"
    />
    <div style="font-size: 12px; color: #666;">
      Your API key is stored only in your browser and is never sent anywhere except to OpenAI's servers.
    </div>
  </div>

  <div style="margin-bottom: 20px; padding: 15px; border: 1px solid #ddd; border-radius: 6px; background-color: #f9f9f9;">
    <label for="bookFiles" style="display: block; margin-bottom: 8px; font-weight: bold;">Select Harry Potter Book Files:</label>
    <input
      type="file"
      id="bookFiles"
      multiple
      accept=".txt"
      style="width: 100%; max-width: 500px; padding: 8px; border: 1px solid #ccc; border-radius: 4px; margin-bottom: 8px;"
    />
    <div style="font-size: 12px; color: #666;">
      Select all 7 book text files (Book1.txt, Book2.txt, etc.). Files are processed locally in your browser.
    </div>
  </div>

  <div style="margin-bottom: 20px; padding: 15px; border: 1px solid #ddd; border-radius: 6px; background-color: #f0f8ff;">
    <label for="csvFile" style="display: block; margin-bottom: 8px; font-weight: bold;">Or Upload CSV for Sentiment Analysis:</label>
    <input
      type="file"
      id="csvFile"
      accept=".csv"
      style="width: 100%; max-width: 500px; padding: 8px; border: 1px solid #ccc; border-radius: 4px; margin-bottom: 8px;"
    />
    <div style="font-size: 12px; color: #666;">
      CSV format: book,speaker,target,sentiment,description<br>
      Example: 1,Vernon Dursley,Vernon Dursley,positive, Mr. and Mrs. Dursley are proud to be perfectly normal...
    </div>
  </div>

  <div id="progress">Waiting to start...</div>
  <button id="startBtn">Start Extraction</button>
  <button id="analyzeSentimentBtn">Analyze Sentiment from CSV</button>
  <pre id="output"></pre>

  <script type="module">
    function getApiKey() {
      return document.getElementById('apiKeyInput').value.trim();
    }

    // Load character names from JSON file
    let validCharacters = [];
    
    // Load character names on page load
    async function loadCharacterNames() {
      try {
        const response = await fetch('./character_names.json');
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        const data = await response.json();
        validCharacters = data.character_names;
        console.log(`✅ Loaded ${validCharacters.length} character names from character_names.json`);
      } catch (error) {
        console.error('❌ Failed to load character names from JSON, using fallback list:', error);
        // Fallback to a minimal character set if JSON fails to load
        validCharacters = [
          "Harry Potter", "Hermione Granger", "Ron Weasley", "Albus Dumbledore", "Severus Snape",
          "Draco Malfoy", "Voldemort", "Rubeus Hagrid", "Minerva McGonagall", "Sirius Black",
          "Students", "Wizards", "Death Eaters", "Order of the Phoenix", "other"
        ];
        alert('Warning: Could not load full character list from character_names.json. Using minimal fallback list. Please ensure the file is available.');
      }
    }

    // Function to read a book file from File object
    async function readBookFile(file) {
      try {
        return await file.text();
      } catch (error) {
        console.error(`Error reading ${file.name}:`, error);
        throw error;
      }
    }

    // Function to parse CSV file and return array of objects
    async function parseCSVFile(file) {
      try {
        const csvText = await file.text();
        const lines = csvText.trim().split('\n');

        if (lines.length < 2) {
          throw new Error('CSV file must have at least a header row and one data row');
        }

        // Parse header
        const header = lines[0].split(',').map(col => col.trim());
        const expectedHeaders = ['book', 'speaker', 'target', 'sentiment', 'description'];

        // Validate headers
        const hasRequiredHeaders = expectedHeaders.every(reqHeader =>
          header.some(h => h.toLowerCase() === reqHeader.toLowerCase())
        );

        if (!hasRequiredHeaders) {
          throw new Error(`CSV must have headers: ${expectedHeaders.join(', ')}`);
        }

        // Parse data rows
        const data = [];
        for (let i = 1; i < lines.length; i++) {
          const line = lines[i].trim();
          if (!line) continue; // Skip empty lines

          // Simple CSV parsing - handles basic cases
          // For production, consider using a proper CSV parser library
          const values = [];
          let current = '';
          let inQuotes = false;

          for (let j = 0; j < line.length; j++) {
            const char = line[j];
            if (char === '"' && (j === 0 || line[j-1] === ',')) {
              inQuotes = true;
            } else if (char === '"' && inQuotes && (j === line.length - 1 || line[j+1] === ',')) {
              inQuotes = false;
            } else if (char === ',' && !inQuotes) {
              values.push(current.trim());
              current = '';
            } else {
              current += char;
            }
          }
          values.push(current.trim()); // Add the last value

          if (values.length !== header.length) {
            console.warn(`Row ${i + 1} has ${values.length} values but header has ${header.length} columns. Skipping row.`);
            continue;
          }

          // Create object with header mapping
          const rowObject = {};
          header.forEach((col, index) => {
            rowObject[col.toLowerCase()] = values[index];
          });

          data.push(rowObject);
        }

        return data;
      } catch (error) {
        console.error(`Error parsing CSV file ${file.name}:`, error);
        throw error;
      }
    }

    // Function to split text into chunks of approximately 1000 words, respecting paragraph boundaries
    function chunkText(text, maxWords = 1000) {
      const chunks = [];
      // Split by double newlines (paragraphs)
      const paragraphs = text.split('\n\n');

      let currentChunk = '';
      let currentWordCount = 0;

      for (const paragraph of paragraphs) {
        const paragraphWords = paragraph.trim().split(/\s+/).length;

        // If adding this paragraph would exceed the limit and we already have content
        if (currentWordCount + paragraphWords > maxWords && currentChunk.length > 0) {
          // Save current chunk and start a new one
          chunks.push(currentChunk.trim());
          currentChunk = paragraph;
          currentWordCount = paragraphWords;
        } else {
          // Add paragraph to current chunk
          if (currentChunk.length > 0) {
            currentChunk += '\n\n' + paragraph;
          } else {
            currentChunk = paragraph;
          }
          currentWordCount += paragraphWords;
        }
      }

      // Add the last chunk if it has content
      if (currentChunk.trim().length > 0) {
        chunks.push(currentChunk.trim());
      }

      return chunks;
    }

    async function makeApiCall(book, chunkIndex, chunkText, previousChunkText = null) {
      const timeoutPromise = new Promise((_, reject) => {
        setTimeout(() => reject(new Error('Request timeout after 30 seconds')), 30000);
      });

      const apiCallPromise = async () => {
        const response = await fetch("https://api.openai.com/v1/chat/completions", {
          method: "POST",
          headers: {
            "Authorization": `Bearer ${getApiKey()}`,
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            model: "gpt-4o",
            messages: [
              {
                role: "system",
                content: `
You are an expert text analyzer. Analyze the provided Harry Potter text and extract ALL remarks and comments made by characters:
- Read the entire text carefully, ensuring no comment or remarks is skipped.
- Include remarks or comments made by any character mentioned in the text, not just the main ones.
- Include remarks or comments made on any kind of group of people or animals or objects, for instance family, musicians, gingers, irish, cats, table....
- Include remarks or comments made behind the back where the subject wasn't present.
- Include remarks or comments happened in the character head, means that it wasn't said out loud but the character only thought it.
- Do not include remarks stated by the narrator or descriptive text.
- Only extract remarks from the provided text - do not use external knowledge.
- When context from a previous section is provided, use it to better understand ongoing conversations and situations, but extract remarks ONLY from the current text section.
- Use the exact character names as they appear in the text for both character_name (who said it) and target (who it was about).
- If the character made a remark about a group, include all the members of the group in the target.
- If the character made a remark someone's belonging or relatives include both the person and the belonging or relatives in the target.
- For each remark, provide a brief description of what was said (1-2 sentences maximum).
- Output strictly as JSON.
- Keep the descriptions short and concise.
                `
              },
              {
                role: "user",
                content: `${previousChunkText ? `Here is some context from the previous section for continuity:
                """
                ${previousChunkText}
                """

                Now extract ALL remarks and comments made by any character from this current text:
                """
                ${chunkText}
                """

                Note: The previous section is provided only for context. Extract remarks ONLY from the current text, not from the context section.` : `Extract ALL remarks and comments made by any character from this text:
                """
                ${chunkText}
                """`}`
              }
            ],
            temperature: 0,
            response_format: {
              type: "json_schema",
              json_schema: {
                  name: "remarks_schema",
                  strict: true,
                  schema: {
                      type: "object",
                      properties: {
                          book: {
                              type: "integer",
                          },
                          remarks: {
                              type: "array",
                              description: "A list of ALL remarks or comments stated by any character.",
                              items: {
                                  type: "object",
                                  properties: {
                                      character_name: {
                                          type: "string",
                                          description: "The character who said the remark.",
                                      },
                                      target: {
                                          type: "array",
                                          items: {
                                              type: "string"
                                          },
                                          description: "The character(s) or group(s) or animal(s) or object(s) who were the subject of the remark. could be also someone's family, friends, animals, objects, etc. in that case need to include the owner or the relative in the target.",
                                      },
                                      sentiment: {
                                          type: "string",
                                          enum: ["negative", "positive", "neutral"],
                                          description:
                                              "Does the remark is a negative (insult or unkind statement) about the subject (target), positive, or neutral.",
                                      },
                                      description: {
                                          type: "string",
                                          description: "A short description of the remark or comment made by the character.",
                                      },
                                  },
                                  required: ["character_name", "sentiment", "target", "description"],
                                  additionalProperties: false,
                              },
                          },
                      },
                      required: ["book", "remarks"],
                      additionalProperties: false,
                  },

              }
            }
          })
        });

        const completion = await response.json();

        try {
          const parsed = JSON.parse(completion.choices[0].message.content);
          return { success: true, data: parsed, book, chunkIndex };
        } catch (err) {
          console.error(`Failed to parse JSON for book ${book}, chunk ${chunkIndex}:`, err);
          return { success: false, error: `Parse error: ${err.message}`, book, chunkIndex };
        }
      };

      try {
        return await Promise.race([apiCallPromise(), timeoutPromise]);
      } catch (err) {
        console.error(`API call failed for book ${book}, chunk ${chunkIndex}:`, err);
        return { success: false, error: err.message, book, chunkIndex };
      }
    }

    async function makeSentimentAnalysisCall(batchData, batchIndex) {
      const timeoutPromise = new Promise((_, reject) => {
        setTimeout(() => reject(new Error('Request timeout after 30 seconds')), 30000);
      });

      const apiCallPromise = async () => {
        const response = await fetch("https://api.openai.com/v1/chat/completions", {
          method: "POST",
          headers: {
            "Authorization": `Bearer ${getApiKey()}`,
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            model: "gpt-4o",
            messages: [
              {
                role: "system",
                content: `
You are an expert sentiment analyzer. You will analyze a batch of remarks/comments and determine the sentiment of each speaker towards their target.

For each item in the batch:
- Analyze the description to understand what the speaker said or thought about or to the target
- Determine if the sentiment is positive, negative, or neutral
- Consider the context and tone of the remark

Return the analysis for all items in the batch with the corrected sentiment values.`
              },
              {
                role: "user",
                content: `Analyze the sentiment for each of these ${batchData.length} remarks (Batch ${batchIndex}):

${batchData.map((item, index) => `
Item ${index}:
Speaker: ${item.speaker}
Target: ${item.target}
Description: ${item.description}
`).join('\n')}

Please return batch_index as ${batchIndex} and use item_index values 0 to ${batchData.length - 1} corresponding to the items above.`
              }
            ],
            temperature: 0,
            response_format: {
              type: "json_schema",
              json_schema: {
                name: "sentiment_analysis_schema",
                strict: true,
                schema: {
                  type: "object",
                  properties: {
                    batch_index: {
                      type: "integer"
                    },
                    analyzed_items: {
                      type: "array",
                      description: "Analysis results for each item in the batch",
                      items: {
                        type: "object",
                        properties: {
                          item_index: {
                            type: "integer",
                            description: "The index of this item within the batch (0-based)"
                          },
                          new_sentiment: {
                            type: "string",
                            enum: ["positive", "negative", "neutral"],
                            description: "Does the speaker said/though something positive, neutral or negative about the target"
                          },
                          reasoning: {
                            type: "string",
                            description: "Brief explanation for the sentiment classification"
                          }
                        },
                        required: ["item_index", "new_sentiment",  "reasoning"],
                        additionalProperties: false
                      }
                    }
                  },
                  required: ["batch_index", "analyzed_items"],
                  additionalProperties: false
                }
              }
            }
          })
        });

        const completion = await response.json();

        try {
          const parsed = JSON.parse(completion.choices[0].message.content);
          return { success: true, data: parsed, batchIndex };
        } catch (err) {
          console.error(`Failed to parse JSON for sentiment batch ${batchIndex}:`, err);
          return { success: false, error: `Parse error: ${err.message}`, batchIndex };
        }
      };

      try {
        return await Promise.race([apiCallPromise(), timeoutPromise]);
      } catch (err) {
        console.error(`Sentiment analysis API call failed for batch ${batchIndex}:`, err);
        return { success: false, error: err.message, batchIndex };
      }
    }

    async function convertCharacterNames(remarkData) {
      // Extract all unique character names from the data
      const uniqueNames = new Set();
      const contextData = [];

      remarkData.remarks.forEach(remark => {
        uniqueNames.add(remark.character_name);
        remark.target.forEach(target => uniqueNames.add(target));

        // Store context for self-reference resolution
        contextData.push({
          speaker: remark.character_name,
          targets: remark.target,
          description: remark.description
        });
      });

      const namesToConvert = Array.from(uniqueNames).filter(name =>
        !validCharacters.includes(name)
      );

      // If no names need conversion, return empty mapping
      if (namesToConvert.length === 0) {
        return { success: true, mapping: {} };
      }

      const timeoutPromise = new Promise((_, reject) => {
        setTimeout(() => reject(new Error('Character conversion timeout after 30 seconds')), 30000);
      });

      const conversionPromise = async () => {
        const response = await fetch("https://api.openai.com/v1/chat/completions", {
          method: "POST",
          headers: {
            "Authorization": `Bearer ${getApiKey()}`,
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            model: "gpt-4o",
            messages: [
              {
                role: "system",
                content: `
You are a Harry Potter character name converter. Your job is to take character names and convert them to the closest match from the predefined list.

For each character name, find the best match from the valid characters list. Special cases:

1. **Families/Groups**: If the name refers to a family or group (e.g., "Ron's family", "the Weasleys", "Hermione's parents"), return ALL individual members from that group that are in the valid list.

2. **Self-references**: If the name refers to the speaker themselves (e.g., "myself", "me", "I", "him", "her"), use the context provided to identify who the speaker is and map it to that character.

3. **Belongings/Relatives**: If the name refers to someone's belongings or relatives (e.g., "Harry's owl", "Hermione's parents", "Ron's rat"), include both the owner AND the belonging/relative if in the valid list.

4. **Regular names**: For regular character names, find the closest match (e.g., "Dumbledore" -> "Albus Dumbledore").

5. **Unknown/Generic**: If no good match exists, use broader categories like "Students", "Wizards", "Muggles", etc., or "other" as last resort.

The valid character names are: ${validCharacters.join(", ")}

Return a mapping where each original name maps to an array of valid character names (even if it's just one character, use an array).
                `
              },
              {
                role: "user",
                content: `Convert these character names to match the valid character list:

                Names to convert: ${JSON.stringify(namesToConvert, null, 2)}

                Context (for resolving self-references and belongings):
                ${JSON.stringify(contextData, null, 2)}

                Use the context to resolve self-references like "myself", "me", "I", "him", "her" to the actual speaker.
                For belongings/relatives (e.g., "Harry's owl", "his parents"), include both the owner and the belonging/relative in the mapped array.`
              }
            ],
            temperature: 0,
            response_format: {
              type: "json_schema",
              json_schema: {
                name: "character_name_mapping",
                strict: false,
                schema: {
                  type: "object",
                  properties: {
                    mapping: {
                      type: "object",
                      description: "A mapping of original character names to arrays of valid character names from the enum list",
                      additionalProperties: {
                        type: "array",
                        items: {
                          type: "string",
                          enum: validCharacters
                        }
                      }
                    }
                  },
                  required: ["mapping"],
                  additionalProperties: false
                }
              }
            }
          })
        });

        const completion = await response.json();

        try {
          const parsed = JSON.parse(completion.choices[0].message.content);
          return { success: true, mapping: parsed.mapping };
        } catch (err) {
          console.error(`Failed to parse conversion JSON:`, err);
          return { success: false, error: `Parse error: ${err.message}` };
        }
      };

      try {
        return await Promise.race([conversionPromise(), timeoutPromise]);
      } catch (err) {
        console.error(`Character conversion failed:`, err);
        return { success: false, error: err.message };
      }
    }

    function applyCharacterMapping(remarkData, mapping) {
      // Create a deep copy of the original data
      const updatedData = JSON.parse(JSON.stringify(remarkData));

      // Apply mapping to character_name and target fields
      updatedData.remarks.forEach(remark => {
        const originalSpeaker = remark.character_name;

        // For character_name (who said it), use the first character from the mapping array
        // since a remark can only be said by one character at a time
        if (mapping[remark.character_name] && Array.isArray(mapping[remark.character_name])) {
          remark.character_name = mapping[remark.character_name][0];
        }

        // For target (who it was about), expand to all mapped characters
        const expandedTargets = [];
        const originalTargets = [...remark.target]; // Store original targets

        remark.target.forEach(target => {
          if (mapping[target] && Array.isArray(mapping[target])) {
            // Add all characters from the mapping array
            expandedTargets.push(...mapping[target]);
          } else {
            // Keep original target if no mapping found
            expandedTargets.push(target);
          }
        });

        // Special handling: If any original target implied the speaker's belongings/relatives
        // (like "my family", "his owl", etc.), the LLM mapping should have included the speaker,
        // but let's ensure the final mapped speaker is also in the targets if it makes sense
        const finalSpeaker = remark.character_name;
        const shouldIncludeSpeaker = originalTargets.some(target =>
          target.toLowerCase().includes('my ') ||
          target.toLowerCase().includes('myself') ||
          target.toLowerCase().includes('me ') ||
          (mapping[target] && mapping[target].includes(finalSpeaker))
        );

        if (shouldIncludeSpeaker && !expandedTargets.includes(finalSpeaker)) {
          expandedTargets.push(finalSpeaker);
        }

        // Remove duplicates and update target array
        remark.target = [...new Set(expandedTargets)];
      });

      return updatedData;
    }

    async function extractInsults(updateProgress) {
      const fileInput = document.getElementById('bookFiles');
      const selectedFiles = Array.from(fileInput.files);

      if (selectedFiles.length === 0) {
        throw new Error('Please select book files first.');
      }

      // Sort files by name to ensure proper book order
      selectedFiles.sort((a, b) => a.name.localeCompare(b.name));

      updateProgress('Reading book files...');

      const allChunkRequests = [];
      let allResults = [];
      let failedChunks = [];

      // Read all book files and create chunks
      for (let fileIndex = 0; fileIndex < selectedFiles.length; fileIndex++) {
        const file = selectedFiles[fileIndex];
        const bookNumber = fileIndex + 1;

        try {
          updateProgress(`Reading ${file.name}...`);
          const bookText = await readBookFile(file);
          const chunks = chunkText(bookText).filter((c,i) => [1, 142].includes(i));

          updateProgress(`${file.name}: Created ${chunks.length} chunks`);

          // Add all chunks for this book to the processing queue
          for (let chunkIndex = 0; chunkIndex < chunks.length; chunkIndex++) {
            allChunkRequests.push({
              book: bookNumber,
              chunkIndex: chunkIndex,
              chunkText: chunks[chunkIndex],
              previousChunkText: chunkIndex > 0 ? chunks[chunkIndex - 1] : null
            });
          }
        } catch (error) {
          console.error(`Failed to read ${file.name}:`, error);
          updateProgress(`❌ Failed to read ${file.name}: ${error.message}`);
        }
      }

      const totalChunks = allChunkRequests.length;
      let completedChunks = 0;

      updateProgress(`Processing ${totalChunks} chunks across ${selectedFiles.length} books...`);

      // Process in batches
      const batchSize = 10;
      for (let i = 0; i < allChunkRequests.length; i += batchSize) {
        const batch = allChunkRequests.slice(i, i + batchSize);
        const batchNumber = Math.floor(i / batchSize) + 1;
        const totalBatches = Math.ceil(allChunkRequests.length / batchSize);

        updateProgress(`Processing batch ${batchNumber}/${totalBatches} (${batch.length} chunks)...`);

        // Execute batch concurrently
        const batchPromises = batch.map(({ book, chunkIndex, chunkText, previousChunkText }) =>
          makeApiCall(book, chunkIndex, chunkText, previousChunkText)
        );
        const batchResults = await Promise.allSettled(batchPromises);

        // Process batch results
        for (let index = 0; index < batchResults.length; index++) {
          completedChunks++;
          const result = batchResults[index];
          const { book, chunkIndex } = batch[index];

          if (result.status === 'fulfilled' && result.value.success) {
            // Convert character names to enum values using mapping
            const conversionResult = await convertCharacterNames(result.value.data);

            if (conversionResult.success && conversionResult.mapping) {
              const updatedData = applyCharacterMapping(result.value.data, conversionResult.mapping);
              allResults.push(updatedData);
            } else {
              // If conversion fails, use original data and log warning
              console.warn(`Character conversion failed for book ${book}, chunk ${chunkIndex}: ${conversionResult.error}`);
              allResults.push(result.value.data);
            }
          } else {
            const errorMessage = result.status === 'fulfilled'
              ? result.value.error
              : result.reason?.message || 'Unknown error';
            failedChunks.push({ book, chunkIndex, error: errorMessage });
            console.error(`Failed to process book ${book}, chunk ${chunkIndex}: ${errorMessage}`);
          }
        }

        updateProgress(`Completed ${completedChunks}/${totalChunks} chunks...`);

        // Small delay between batches to be respectful to the API
        if (i + batchSize < allChunkRequests.length) {
          await new Promise(r => setTimeout(r, 1000));
        }
      }

      // Retry failed chunks one by one
      let retriedChunks = [];
      let remainingFailures = [];

      if (failedChunks.length > 0) {
        updateProgress(`Retrying ${failedChunks.length} failed chunks one by one...`);

        for (let i = 0; i < failedChunks.length; i++) {
          const { book, chunkIndex } = failedChunks[i];
          const originalChunk = allChunkRequests.find(req =>
            req.book === book && req.chunkIndex === chunkIndex
          );

          if (!originalChunk) {
            console.error(`Could not find original chunk data for book ${book}, chunk ${chunkIndex}`);
            remainingFailures.push(failedChunks[i]);
            continue;
          }

          updateProgress(`Retrying ${i + 1}/${failedChunks.length}: Book ${book}, Chunk ${chunkIndex}...`);

          try {
            const retryResult = await makeApiCall(book, chunkIndex, originalChunk.chunkText, originalChunk.previousChunkText);

            if (retryResult.success) {
              // Convert character names to enum values using mapping
              const conversionResult = await convertCharacterNames(retryResult.data);

              if (conversionResult.success && conversionResult.mapping) {
                const updatedData = applyCharacterMapping(retryResult.data, conversionResult.mapping);
                allResults.push(updatedData);
                retriedChunks.push({ book, chunkIndex });
              } else {
                // If conversion fails, use original data and log warning
                console.warn(`Character conversion failed for retry of book ${book}, chunk ${chunkIndex}: ${conversionResult.error}`);
                allResults.push(retryResult.data);
                retriedChunks.push({ book, chunkIndex });
              }
              updateProgress(`✅ Retry successful: Book ${book}, Chunk ${chunkIndex}`);
            } else {
              remainingFailures.push({ book, chunkIndex, error: retryResult.error });
              updateProgress(`❌ Retry failed: Book ${book}, Chunk ${chunkIndex} - ${retryResult.error}`);
            }
          } catch (error) {
            remainingFailures.push({ book, chunkIndex, error: error.message });
            updateProgress(`❌ Retry failed: Book ${book}, Chunk ${chunkIndex} - ${error.message}`);
          }

          // Add a small delay between retry attempts
          if (i < failedChunks.length - 1) {
            await new Promise(r => setTimeout(r, 2000));
          }
        }
      }

      // Group remaining failed chunks by book for summary
      const remainingFailedByBook = {};
      remainingFailures.forEach(({ book, chunkIndex, error }) => {
        if (!remainingFailedByBook[book]) {
          remainingFailedByBook[book] = [];
        }
        remainingFailedByBook[book].push({ chunkIndex, error });
      });

      // Group successfully retried chunks by book
      const retriedByBook = {};
      retriedChunks.forEach(({ book, chunkIndex }) => {
        if (!retriedByBook[book]) {
          retriedByBook[book] = [];
        }
        retriedByBook[book].push(chunkIndex);
      });

      return {
        results: allResults,
        failed: remainingFailedByBook,
        totalFailed: remainingFailures.length,
        totalSuccess: allResults.length,
        retriedSuccess: retriedChunks.length,
        retriedByBook: retriedByBook,
        originalFailures: failedChunks.length
      };
    }

    async function analyzeSentimentFromCSV(updateProgress) {
      const csvFileInput = document.getElementById('csvFile');

      if (!csvFileInput.files.length) {
        throw new Error('Please select a CSV file first.');
      }

      const csvFile = csvFileInput.files[0];
      updateProgress(`Reading CSV file: ${csvFile.name}...`);

      // Parse CSV file
      const csvData = await parseCSVFile(csvFile);
      updateProgress(`Parsed ${csvData.length} rows from CSV file`);

      if (csvData.length === 0) {
        throw new Error('No data rows found in CSV file');
      }

      // Process in batches
      const batchSize = 20; // Larger batches since we're not processing huge text chunks
      const maxParallelBatches = 5; // Maximum number of batches to process in parallel
      let allResults = [];
      let failedBatches = [];
      const totalBatches = Math.ceil(csvData.length / batchSize);
      let completedBatches = 0;

      updateProgress(`Processing ${csvData.length} items in ${totalBatches} batches (max ${maxParallelBatches} parallel)...`);

      // Create all batch requests
      const allBatchRequests = [];
      for (let i = 0; i < csvData.length; i += batchSize) {
        const batch = csvData.slice(i, i + batchSize);
        const batchIndex = Math.floor(i / batchSize);
        allBatchRequests.push({ batch, batchIndex });
      }

      // Process batches in parallel groups
      for (let i = 0; i < allBatchRequests.length; i += maxParallelBatches) {
        const parallelBatches = allBatchRequests.slice(i, i + maxParallelBatches);
        const groupNumber = Math.floor(i / maxParallelBatches) + 1;
        const totalGroups = Math.ceil(allBatchRequests.length / maxParallelBatches);

        updateProgress(`Processing batch group ${groupNumber}/${totalGroups} (${parallelBatches.length} batches in parallel)...`);

        // Execute batches in parallel
        const batchPromises = parallelBatches.map(({ batch, batchIndex }) =>
          makeSentimentAnalysisCall(batch, batchIndex)
        );
        const batchResults = await Promise.allSettled(batchPromises);

        // Process results
        for (let j = 0; j < batchResults.length; j++) {
          completedBatches++;
          const result = batchResults[j];
          const { batch, batchIndex } = parallelBatches[j];

          if (result.status === 'fulfilled' && result.value.success) {
            allResults.push(result.value.data);
            updateProgress(`✅ Completed batch ${batchIndex + 1}/${totalBatches} in group ${groupNumber}`);
          } else {
            const errorMessage = result.status === 'fulfilled'
              ? result.value.error
              : result.reason?.message || 'Unknown error';
            failedBatches.push({ batchIndex, batch, error: errorMessage });
            updateProgress(`❌ Failed batch ${batchIndex + 1}/${totalBatches}: ${errorMessage}`);
          }
        }

        updateProgress(`Completed group ${groupNumber}/${totalGroups} - ${completedBatches}/${totalBatches} batches processed`);

        // Small delay between parallel groups to be respectful to the API
        if (i + maxParallelBatches < allBatchRequests.length) {
          await new Promise(r => setTimeout(r, 1000));
        }
      }

      // Retry failed batches one by one
      let retriedBatches = [];
      let remainingFailures = [];

      if (failedBatches.length > 0) {
        updateProgress(`Retrying ${failedBatches.length} failed batches...`);

        for (let i = 0; i < failedBatches.length; i++) {
          const { batchIndex, batch, error } = failedBatches[i];

          updateProgress(`Retrying ${i + 1}/${failedBatches.length}: Batch ${batchIndex}...`);

          try {
            const retryResult = await makeSentimentAnalysisCall(batch, batchIndex);

            if (retryResult.success) {
              allResults.push(retryResult.data);
              retriedBatches.push({ batchIndex });
              updateProgress(`✅ Retry successful: Batch ${batchIndex}`);
            } else {
              remainingFailures.push({ batchIndex, batch, error: retryResult.error });
              updateProgress(`❌ Retry failed: Batch ${batchIndex} - ${retryResult.error}`);
            }
          } catch (retryError) {
            remainingFailures.push({ batchIndex, batch, error: retryError.message });
            updateProgress(`❌ Retry failed: Batch ${batchIndex} - ${retryError.message}`);
          }

          // Add a delay between retry attempts
          if (i < failedBatches.length - 1) {
            await new Promise(r => setTimeout(r, 2000));
          }
        }
      }

      return {
        results: allResults,
        originalData: csvData, // Include original CSV data for reference
        totalItems: csvData.length,
        totalBatches: totalBatches,
        successfulBatches: allResults.length,
        originalFailures: failedBatches.length,
        retriedSuccess: retriedBatches.length,
        remainingFailures: remainingFailures.length,
        failedBatches: remainingFailures
      };
    }

    document.getElementById("startBtn").addEventListener("click", async () => {
      const progressEl = document.getElementById("progress");
      const outputEl = document.getElementById("output");
      const apiKey = getApiKey();

      // Validate inputs
      if (!apiKey) {
        progressEl.textContent = "❌ Please enter your OpenAI API key before starting extraction.";
        progressEl.style.color = "red";
        return;
      }

      if (!apiKey.startsWith('sk-')) {
        progressEl.textContent = "❌ Invalid API key format. OpenAI API keys start with 'sk-'.";
        progressEl.style.color = "red";
        return;
      }

      const fileInput = document.getElementById('bookFiles');
      if (fileInput.files.length === 0) {
        progressEl.textContent = "❌ Please select book files before starting extraction.";
        progressEl.style.color = "red";
        return;
      }

      // Reset progress color
      progressEl.style.color = "";
      progressEl.textContent = "Starting extraction...";

      try {
        const extractionResults = await extractInsults(msg => {
          progressEl.textContent = msg;
        });

        // Create summary message with retry information
        let summary = `Done! Successfully processed ${extractionResults.totalSuccess} chunks.`;
        if (extractionResults.originalFailures > 0) {
          summary += ` Originally ${extractionResults.originalFailures} chunks failed.`;
          if (extractionResults.retriedSuccess > 0) {
            summary += ` Successfully retried ${extractionResults.retriedSuccess} chunks.`;
          }
          if (extractionResults.totalFailed > 0) {
            summary += ` ${extractionResults.totalFailed} chunks remain failed after retry.`;
          } else {
            summary += ` All failed chunks were successfully retried!`;
          }
        }
        progressEl.textContent = summary;

        // Prepare output with results and retry summary
        let output = {
          successful_chunks: extractionResults.results,
          summary: {
            total_chunks: extractionResults.totalSuccess + extractionResults.totalFailed,
            successful: extractionResults.totalSuccess,
            original_failures: extractionResults.originalFailures,
            retried_successes: extractionResults.retriedSuccess,
            remaining_failures: extractionResults.totalFailed
          }
        };

        // Add retry success summary if there were successful retries
        if (extractionResults.retriedSuccess > 0) {
          output.successfully_retried_chunks_by_book = {};
          Object.entries(extractionResults.retriedByBook).forEach(([book, chunkIndexes]) => {
            output.successfully_retried_chunks_by_book[`Book ${book}`] = {
              retried_count: chunkIndexes.length,
              chunk_indexes: chunkIndexes
            };
          });
        }

        // Add remaining failed chunks summary if there are any remaining failures
        if (extractionResults.totalFailed > 0) {
          output.remaining_failed_chunks_by_book = {};
          Object.entries(extractionResults.failed).forEach(([book, chunks]) => {
            output.remaining_failed_chunks_by_book[`Book ${book}`] = {
              failed_count: chunks.length,
              chunks: chunks.map(ch => `Chunk ${ch.chunkIndex}: ${ch.error}`)
            };
          });
        }

        outputEl.textContent = JSON.stringify(output, null, 2);
      } catch (error) {
        progressEl.textContent = `❌ Error: ${error.message}`;
        progressEl.style.color = "red";
        console.error('Extraction error:', error);
      }
    });

    document.getElementById("analyzeSentimentBtn").addEventListener("click", async () => {
      const progressEl = document.getElementById("progress");
      const outputEl = document.getElementById("output");
      const apiKey = getApiKey();

      // Validate inputs
      if (!apiKey) {
        progressEl.textContent = "❌ Please enter your OpenAI API key before starting sentiment analysis.";
        progressEl.style.color = "red";
        return;
      }

      if (!apiKey.startsWith('sk-')) {
        progressEl.textContent = "❌ Invalid API key format. OpenAI API keys start with 'sk-'.";
        progressEl.style.color = "red";
        return;
      }

      const csvFileInput = document.getElementById('csvFile');
      if (csvFileInput.files.length === 0) {
        progressEl.textContent = "❌ Please select a CSV file before starting sentiment analysis.";
        progressEl.style.color = "red";
        return;
      }

      // Reset progress color
      progressEl.style.color = "";
      progressEl.textContent = "Starting sentiment analysis...";

      try {
        const analysisResults = await analyzeSentimentFromCSV(msg => {
          progressEl.textContent = msg;
        });

        // Create summary message (will be updated after processing)
        let summary = `Processing complete! Preparing results...`;
        progressEl.textContent = summary;

        // Create CSV-like output with original data plus new sentiment column
        const csvResults = [...analysisResults.originalData]; // Start with all original items

        // Create a map to track which items have been processed
        const processedItems = new Map();

        // Process all successfully analyzed items
        analysisResults.results.forEach(batchResult => {
          batchResult.analyzed_items.forEach(item => {
            // Calculate the correct global index for this item
            const globalIndex = batchResult.batch_index * 20 + item.item_index;
            processedItems.set(globalIndex, {
              new_sentiment: item.new_sentiment,
              reasoning: item.reasoning
            });
          });
        });

        // Apply the analysis results to the corresponding original items
        csvResults.forEach((originalItem, index) => {
          if (processedItems.has(index)) {
            const analysisResult = processedItems.get(index);
            originalItem.new_sentiment = analysisResult.new_sentiment;
            originalItem.reasoning = analysisResult.reasoning;
          } else {
            // Item wasn't processed (likely due to batch failure)
            originalItem.new_sentiment = "";
            originalItem.reasoning = "Not processed due to batch failure";
          }
        });

        // Count processed vs unprocessed items
        const processedCount = csvResults.filter(item => item.new_sentiment && item.new_sentiment !== "").length;
        const unprocessedCount = csvResults.filter(item => !item.new_sentiment || item.new_sentiment === "").length;

        // Prepare output
        let output = {
          csv_results: csvResults,
          summary: {
            total_items: analysisResults.totalItems,
            processed_items: processedCount,
            unprocessed_items: unprocessedCount,
            total_batches: analysisResults.totalBatches,
            successful_batches: analysisResults.successfulBatches,
            original_failures: analysisResults.originalFailures,
            retried_successes: analysisResults.retriedSuccess,
            remaining_failures: analysisResults.remainingFailures
          },
          csv_headers: ["book", "speaker", "target", "sentiment", "description", "new_sentiment", "reasoning"]
        };

        // Add failed batches information if there are remaining failures
        if (analysisResults.remainingFailures > 0) {
          output.failed_batches = analysisResults.failedBatches.map(fb => ({
            batch_index: fb.batchIndex,
            error: fb.error,
            items_count: fb.batch.length
          }));
        }

        outputEl.textContent = JSON.stringify(output, null, 2);

        // Update final summary message
        const finalProcessedCount = output.summary.processed_items;
        const finalUnprocessedCount = output.summary.unprocessed_items;
        const totalCount = output.summary.total_items;

        let finalSummary = `Done! Successfully analyzed ${finalProcessedCount}/${totalCount} items.`;
        if (finalUnprocessedCount > 0) {
          finalSummary += ` ${finalUnprocessedCount} items could not be processed due to batch failures.`;
        }
        if (analysisResults.originalFailures > 0) {
          finalSummary += ` (Originally ${analysisResults.originalFailures} batches failed`;
          if (analysisResults.retriedSuccess > 0) {
            finalSummary += `, ${analysisResults.retriedSuccess} successfully retried`;
          }
          finalSummary += `)`;
        }
        progressEl.textContent = finalSummary;
      } catch (error) {
        progressEl.textContent = `❌ Error: ${error.message}`;
        progressEl.style.color = "red";
        console.error('Sentiment analysis error:', error);
      }
    });

    // Initialize character names on page load
    window.addEventListener('DOMContentLoaded', function() {
      loadCharacterNames();
    });
  </script>
</body>
</html>
