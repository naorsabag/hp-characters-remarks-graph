<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>HP Character Remarks Extractor</title>
  <style>
    body {
      font-family: sans-serif;
      margin: 20px;
    }
    #progress {
      font-weight: bold;
      margin-bottom: 10px;
    }
    pre {
      background: #f4f4f4;
      padding: 10px;
      border-radius: 6px;
      max-height: 400px;
      overflow: auto;
    }
  </style>
</head>
<body>
  <h1>Harry Potter Character Remarks Extractor</h1>

  <div style="margin-bottom: 20px; padding: 15px; border: 1px solid #ddd; border-radius: 6px; background-color: #f9f9f9;">
    <label for="apiKeyInput" style="display: block; margin-bottom: 8px; font-weight: bold;">OpenAI API Key:</label>
    <input
      type="password"
      id="apiKeyInput"
      placeholder="Enter your OpenAI API key (sk-...)"
      style="width: 100%; max-width: 500px; padding: 8px; border: 1px solid #ccc; border-radius: 4px; margin-bottom: 8px;"
    />
    <div style="font-size: 12px; color: #666;">
      Your API key is stored only in your browser and is never sent anywhere except to OpenAI's servers.
    </div>
  </div>

  <div style="margin-bottom: 20px; padding: 15px; border: 1px solid #ddd; border-radius: 6px; background-color: #f9f9f9;">
    <label for="bookFiles" style="display: block; margin-bottom: 8px; font-weight: bold;">Select Harry Potter Book Files:</label>
    <input
      type="file"
      id="bookFiles"
      multiple
      accept=".txt"
      style="width: 100%; max-width: 500px; padding: 8px; border: 1px solid #ccc; border-radius: 4px; margin-bottom: 8px;"
    />
    <div style="font-size: 12px; color: #666;">
      Select all 7 book text files (Book1.txt, Book2.txt, etc.). Files are processed locally in your browser.
    </div>
  </div>

  <div id="progress">Waiting to start...</div>
  <button id="startBtn">Start Extraction</button>
  <pre id="output"></pre>

  <script type="module">
    function getApiKey() {
      return document.getElementById('apiKeyInput').value.trim();
    }

    const validCharacters = [
      "Vernon Dursley", "Aberforth Dumbledore", "Alastor Moody", "Albus Dumbledore", "Alecto Carrow",
      "Alicia Spinnet", "Amelia Bones", "Amycus Carrow", "Angelina Johnson", "Aragog", "Argus Filch",
      "Ariana Dumbledore", "Arthur Weasley", "Aunt Marge", "Aurors", "Avery", "Bagman", "Bane",
      "Barty Crouch Jr.", "Barty Crouch Sr.", "Bathilda Bagshot", "Beauxbatons students", "Bellatrix Lestrange",
      "Bertha Jorkins", "Bill Weasley", "Blaise Zabini", "Boggart", "Brazil", "Buckbeak",
      "Bulgarian Quidditch Team", "Bulgarians", "Cedric Diggory", "Champions", "Charity Burbage",
      "Charlie Weasley", "chess pieces", "Cho Chang", "Colonel Fubster", "Cormac McLaggen",
      "Cornelius Fudge", "Cornish pixies", "Crabbe", "Crookshanks", "Dawlish", "Dean Thomas",
      "Death", "Death Eater (Dolohov)", "Death Eater (Lestrange)", "Death Eater (Macnair)",
      "Death Eater (Nott)", "Death Eaters", "Dedalus Diggle", "Dementors", "Devil's Snare",
      "Dirigible plums", "Divination", "Dobby", "Dogs", "Dolores Umbridge", "Draco Malfoy",
      "dragon eggs", "Dragons", "Dudley Dursley", "Durmstrang", "Egypt", "Eldred Worple",
      "Emmeline Vance", "Ernie Macmillan", "Ernie Prang", "Fang", "Fat Lady", "Fawkes",
      "Fenrir Greyback", "Filius Flitwick", "Firenze", "Fleur Delacour", "Forbidden Forest",
      "Frank Bryce", "Fred Weasley", "Gellert Grindelwald", "George Weasley", "Giants", "Colin Creevey",
      "Gilderoy Lockhart", "Ginny Weasley", "girls", "Goblins", "boys", "Godric's Hollow",
      "Goyle", "Gringotts", "Griphook", "Gryffindor (the wizard)", "Gryffindor House",
      "Gwenog Jones", "Half-Blood Prince", "half-giants", "Harry Potter", "Harry Potter's friends",
      "Hedwig", "Errol", "Owl/s (with no specific name)", "Mr. Borgin", "Hepzibah Smith", "Hermione Granger", "Hestia Jones", "Hippogriffs", "Hogwarts",
      "Hokey (house-elf)", "Horace Slughorn", "Horcruxes", "House-elves", "Hufflepuff", "Humans",
      "Igor Karkaroff", "Inferi", "Ireland", "James Potter", "Justin Finch-Fletchley",
      "Kendra Dumbledore", "Kingsley Shacklebolt", "Kreacher", "Lavender Brown", "Leaky Cauldron",
      "Lee Jordan", "Lily Potter", "Lucius Malfoy", "Ludo Bagman", "Luna Lovegood", "Madam Malkin",
      "Mandrakes", "Marcus Flint", "Marietta Edgecombe", "Mary Cattermole", "Masons", "McLaggen",
      "Michael Corner", "Minerva McGonagall", "Ministry of Magic", "Moaning Myrtle", "Molly Weasley",
      "Mrs. Figg", "Mrs. Norris", "Mudbloods", "Muggle campsite manager",
      "Muggle Prime Minister", "Muggles", "Mundungus Fletcher", "Musicians", "Nagini", "Narcissa Malfoy",
      "Nearly Headless Nick", "Neville Longbottom", "Nicolas Flamel", "Norbert (the dragon)",
      "Nymphadora Tonks", "Olive Hornby", "Oliver Wood", "Ollivander", "Olympe Maxime",
      "Order of the Phoenix", "Padma Patil", "Pansy Parkinson", "Parvati Patil", "Patronus Charm",
      "Peeves", "Penelope Clearwater", "Percival Dumbledore", "Percy Weasley", "Peter Pettigrew", "Sir Patrick",
      "Petunia Dursley", "Piers Polkiss", "Pius Thicknesse", "police", "Pomona Sprout", "Professor Binns",
      "Potions textbook", "Quidditch", "Quirinus Quirrell", "Ravenclaw", "Reg Cattermole", "Madam Pince", "Madam Pomfrey",
      "Regulus Black", "Remus Lupin", "Rita Skeeter", "Roger Davies", "Rolanda Hooch", "Romilda Vane", "Professor Dippet",
      "Ron Weasley", "Ronan", "Rubeus Hagrid", "Rufus Scrimgeour", "Sanguini (the vampire)", "Gnome",
      "Scabior (Snatcher)", "Seamus Finnigan", "Severus Snape", "Sirius Black", "Slughorn",
      "Slytherin", "Snake", "Snatchers", "Sorting Hat", "spiders", "Squibs", "Stan Shunpike",
      "start-of-term banquet", "Students", "Susan Bones", "Sybill Trelawney", "target", "Terry Boot",
      "the cave", "The Daily Prophet", "the Dark Mark", "The Death Eaters", "The Deathly Hallows",
      "the Lestranges", "The Ministry", "the Mirror of Erised", "the monster in the Chamber",
      "The Peverell family", "the potion", "The Prophecy", "The Quibbler", "staff",
      "the Stone (Philosopher's Stone)", "students", "The Sword of Gryffindor",
      "The Tale of the Three Brothers", "Thestrals", "third-floor corridor", "Tom (Leaky Cauldron landlord)",
      "Triwizard Tournament", "Troll", "Unforgivable Curses", "Vampires", "Veela", "Viktor Krum",
      "villagers", "Voldemort", "Wands", "Weather", "wedding guests", "Winky", "Wizards",
      "Xenophilius Lovegood", "Yaxley", "Zacharias Smith", "other"
    ];

    // Function to read a book file from File object
    async function readBookFile(file) {
      try {
        return await file.text();
      } catch (error) {
        console.error(`Error reading ${file.name}:`, error);
        throw error;
      }
    }

    // Function to split text into chunks of approximately 1000 words, respecting paragraph boundaries
    function chunkText(text, maxWords = 1000) {
      const chunks = [];
      // Split by double newlines (paragraphs)
      const paragraphs = text.split('\n\n');

      let currentChunk = '';
      let currentWordCount = 0;

      for (const paragraph of paragraphs) {
        const paragraphWords = paragraph.trim().split(/\s+/).length;

        // If adding this paragraph would exceed the limit and we already have content
        if (currentWordCount + paragraphWords > maxWords && currentChunk.length > 0) {
          // Save current chunk and start a new one
          chunks.push(currentChunk.trim());
          currentChunk = paragraph;
          currentWordCount = paragraphWords;
        } else {
          // Add paragraph to current chunk
          if (currentChunk.length > 0) {
            currentChunk += '\n\n' + paragraph;
          } else {
            currentChunk = paragraph;
          }
          currentWordCount += paragraphWords;
        }
      }

      // Add the last chunk if it has content
      if (currentChunk.trim().length > 0) {
        chunks.push(currentChunk.trim());
      }

      return chunks;
    }

    async function makeApiCall(book, chunkIndex, chunkText, previousChunkText = null) {
      const timeoutPromise = new Promise((_, reject) => {
        setTimeout(() => reject(new Error('Request timeout after 30 seconds')), 30000);
      });

      const apiCallPromise = async () => {
        const response = await fetch("https://api.openai.com/v1/chat/completions", {
          method: "POST",
          headers: {
            "Authorization": `Bearer ${getApiKey()}`,
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            model: "gpt-4o",
            messages: [
              {
                role: "system",
                content: `
You are an expert text analyzer. Analyze the provided Harry Potter text and extract ALL remarks and comments made by characters:
- Read the entire text carefully, ensuring no comment or remarks is skipped.
- Include remarks or comments made by any character mentioned in the text, not just the main ones.
- Include remarks or comments made on any kind of group of people or animals or objects, for instance family, musicians, gingers, irish, cats, table....
- Include remarks or comments made behind the back where the subject wasn't present.
- Include remarks or comments happened in the character head, means that it wasn't said out loud but the character only thought it.
- Do not include remarks stated by the narrator or descriptive text.
- Only extract remarks from the provided text - do not use external knowledge.
- When context from a previous section is provided, use it to better understand ongoing conversations and situations, but extract remarks ONLY from the current text section.
- Use the exact character names as they appear in the text for both character_name (who said it) and target (who it was about).
- If the character made a remark about a group, include all the members of the group in the target.
- If the character made a remark someone's belonging or relatives include both the person and the belonging or relatives in the target.
- For each remark, provide a brief description of what was said (1-2 sentences maximum).
- Output strictly as JSON.
- Keep the descriptions short and concise.
                `
              },
              {
                role: "user",
                content: `${previousChunkText ? `Here is some context from the previous section for continuity:
                """
                ${previousChunkText}
                """

                Now extract ALL remarks and comments made by any character from this current text:
                """
                ${chunkText}
                """

                Note: The previous section is provided only for context. Extract remarks ONLY from the current text, not from the context section.` : `Extract ALL remarks and comments made by any character from this text:
                """
                ${chunkText}
                """`}`
              }
            ],
            temperature: 0,
            response_format: {
              type: "json_schema",
              json_schema: {
                  name: "remarks_schema",
                  strict: true,
                  schema: {
                      type: "object",
                      properties: {
                          book: {
                              type: "integer",
                          },
                          remarks: {
                              type: "array",
                              description: "A list of ALL remarks or comments stated by any character.",
                              items: {
                                  type: "object",
                                  properties: {
                                      character_name: {
                                          type: "string",
                                          description: "The character who said the remark.",
                                      },
                                      target: {
                                          type: "array",
                                          items: {
                                              type: "string"
                                          },
                                          description: "The character(s) or group(s) or animal(s) or object(s) who were the subject of the remark. could be also someone's family, friends, animals, objects, etc. in that case need to include the owner or the relative in the target.",
                                      },
                                      sentiment: {
                                          type: "string",
                                          enum: ["negative", "positive", "neutral"],
                                          description:
                                              "Does the remark is a negative (insult or unkind statement) about the subject (target), positive, or neutral.",
                                      },
                                      description: {
                                          type: "string",
                                          description: "A short description of the remark or comment made by the character.",
                                      },
                                  },
                                  required: ["character_name", "sentiment", "target", "description"],
                                  additionalProperties: false,
                              },
                          },
                      },
                      required: ["book", "remarks"],
                      additionalProperties: false,
                  },

              }
            }
          })
        });

        const completion = await response.json();

        try {
          const parsed = JSON.parse(completion.choices[0].message.content);
          return { success: true, data: parsed, book, chunkIndex };
        } catch (err) {
          console.error(`Failed to parse JSON for book ${book}, chunk ${chunkIndex}:`, err);
          return { success: false, error: `Parse error: ${err.message}`, book, chunkIndex };
        }
      };

      try {
        return await Promise.race([apiCallPromise(), timeoutPromise]);
      } catch (err) {
        console.error(`API call failed for book ${book}, chunk ${chunkIndex}:`, err);
        return { success: false, error: err.message, book, chunkIndex };
      }
    }

    async function convertCharacterNames(remarkData) {
      // Extract all unique character names from the data
      const uniqueNames = new Set();
      const contextData = [];

      remarkData.remarks.forEach(remark => {
        uniqueNames.add(remark.character_name);
        remark.target.forEach(target => uniqueNames.add(target));

        // Store context for self-reference resolution
        contextData.push({
          speaker: remark.character_name,
          targets: remark.target,
          description: remark.description
        });
      });

      const namesToConvert = Array.from(uniqueNames).filter(name =>
        !validCharacters.includes(name)
      );

      // If no names need conversion, return empty mapping
      if (namesToConvert.length === 0) {
        return { success: true, mapping: {} };
      }

      const timeoutPromise = new Promise((_, reject) => {
        setTimeout(() => reject(new Error('Character conversion timeout after 30 seconds')), 30000);
      });

      const conversionPromise = async () => {
        const response = await fetch("https://api.openai.com/v1/chat/completions", {
          method: "POST",
          headers: {
            "Authorization": `Bearer ${getApiKey()}`,
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            model: "gpt-4o",
            messages: [
              {
                role: "system",
                content: `
You are a Harry Potter character name converter. Your job is to take character names and convert them to the closest match from the predefined list.

For each character name, find the best match from the valid characters list. Special cases:

1. **Families/Groups**: If the name refers to a family or group (e.g., "Ron's family", "the Weasleys", "Hermione's parents"), return ALL individual members from that group that are in the valid list.

2. **Self-references**: If the name refers to the speaker themselves (e.g., "myself", "me", "I", "him", "her"), use the context provided to identify who the speaker is and map it to that character.

3. **Belongings/Relatives**: If the name refers to someone's belongings or relatives (e.g., "Harry's owl", "Hermione's parents", "Ron's rat"), include both the owner AND the belonging/relative if in the valid list.

4. **Regular names**: For regular character names, find the closest match (e.g., "Dumbledore" -> "Albus Dumbledore").

5. **Unknown/Generic**: If no good match exists, use broader categories like "Students", "Wizards", "Muggles", etc., or "other" as last resort.

The valid character names are: ${validCharacters.join(", ")}

Return a mapping where each original name maps to an array of valid character names (even if it's just one character, use an array).
                `
              },
              {
                role: "user",
                content: `Convert these character names to match the valid character list:

                Names to convert: ${JSON.stringify(namesToConvert, null, 2)}

                Context (for resolving self-references and belongings):
                ${JSON.stringify(contextData, null, 2)}

                Use the context to resolve self-references like "myself", "me", "I", "him", "her" to the actual speaker.
                For belongings/relatives (e.g., "Harry's owl", "his parents"), include both the owner and the belonging/relative in the mapped array.`
              }
            ],
            temperature: 0,
            response_format: {
              type: "json_schema",
              json_schema: {
                name: "character_name_mapping",
                strict: false,
                schema: {
                  type: "object",
                  properties: {
                    mapping: {
                      type: "object",
                      description: "A mapping of original character names to arrays of valid character names from the enum list",
                      additionalProperties: {
                        type: "array",
                        items: {
                          type: "string",
                          enum: validCharacters
                        }
                      }
                    }
                  },
                  required: ["mapping"],
                  additionalProperties: false
                }
              }
            }
          })
        });

        const completion = await response.json();

        try {
          const parsed = JSON.parse(completion.choices[0].message.content);
          return { success: true, mapping: parsed.mapping };
        } catch (err) {
          console.error(`Failed to parse conversion JSON:`, err);
          return { success: false, error: `Parse error: ${err.message}` };
        }
      };

      try {
        return await Promise.race([conversionPromise(), timeoutPromise]);
      } catch (err) {
        console.error(`Character conversion failed:`, err);
        return { success: false, error: err.message };
      }
    }

    function applyCharacterMapping(remarkData, mapping) {
      // Create a deep copy of the original data
      const updatedData = JSON.parse(JSON.stringify(remarkData));

      // Apply mapping to character_name and target fields
      updatedData.remarks.forEach(remark => {
        const originalSpeaker = remark.character_name;

        // For character_name (who said it), use the first character from the mapping array
        // since a remark can only be said by one character at a time
        if (mapping[remark.character_name] && Array.isArray(mapping[remark.character_name])) {
          remark.character_name = mapping[remark.character_name][0];
        }

        // For target (who it was about), expand to all mapped characters
        const expandedTargets = [];
        const originalTargets = [...remark.target]; // Store original targets

        remark.target.forEach(target => {
          if (mapping[target] && Array.isArray(mapping[target])) {
            // Add all characters from the mapping array
            expandedTargets.push(...mapping[target]);
          } else {
            // Keep original target if no mapping found
            expandedTargets.push(target);
          }
        });

        // Special handling: If any original target implied the speaker's belongings/relatives
        // (like "my family", "his owl", etc.), the LLM mapping should have included the speaker,
        // but let's ensure the final mapped speaker is also in the targets if it makes sense
        const finalSpeaker = remark.character_name;
        const shouldIncludeSpeaker = originalTargets.some(target =>
          target.toLowerCase().includes('my ') ||
          target.toLowerCase().includes('myself') ||
          target.toLowerCase().includes('me ') ||
          (mapping[target] && mapping[target].includes(finalSpeaker))
        );

        if (shouldIncludeSpeaker && !expandedTargets.includes(finalSpeaker)) {
          expandedTargets.push(finalSpeaker);
        }

        // Remove duplicates and update target array
        remark.target = [...new Set(expandedTargets)];
      });

      return updatedData;
    }

    async function extractInsults(updateProgress) {
      const fileInput = document.getElementById('bookFiles');
      const selectedFiles = Array.from(fileInput.files);

      if (selectedFiles.length === 0) {
        throw new Error('Please select book files first.');
      }

      // Sort files by name to ensure proper book order
      selectedFiles.sort((a, b) => a.name.localeCompare(b.name));

      updateProgress('Reading book files...');

      const allChunkRequests = [];
      let allResults = [];
      let failedChunks = [];

      // Read all book files and create chunks
      for (let fileIndex = 0; fileIndex < selectedFiles.length; fileIndex++) {
        const file = selectedFiles[fileIndex];
        const bookNumber = fileIndex + 1;

        try {
          updateProgress(`Reading ${file.name}...`);
          const bookText = await readBookFile(file);
          const chunks = chunkText(bookText);

          updateProgress(`${file.name}: Created ${chunks.length} chunks`);

          // Add all chunks for this book to the processing queue
          for (let chunkIndex = 0; chunkIndex < chunks.length; chunkIndex++) {
            allChunkRequests.push({
              book: bookNumber,
              chunkIndex: chunkIndex,
              chunkText: chunks[chunkIndex],
              previousChunkText: chunkIndex > 0 ? chunks[chunkIndex - 1] : null
            });
          }
        } catch (error) {
          console.error(`Failed to read ${file.name}:`, error);
          updateProgress(`❌ Failed to read ${file.name}: ${error.message}`);
        }
      }

      const totalChunks = allChunkRequests.length;
      let completedChunks = 0;

      updateProgress(`Processing ${totalChunks} chunks across ${selectedFiles.length} books...`);

      // Process in batches
      const batchSize = 10;
      for (let i = 0; i < allChunkRequests.length; i += batchSize) {
        const batch = allChunkRequests.slice(i, i + batchSize);
        const batchNumber = Math.floor(i / batchSize) + 1;
        const totalBatches = Math.ceil(allChunkRequests.length / batchSize);

        updateProgress(`Processing batch ${batchNumber}/${totalBatches} (${batch.length} chunks)...`);

        // Execute batch concurrently
        const batchPromises = batch.map(({ book, chunkIndex, chunkText, previousChunkText }) =>
          makeApiCall(book, chunkIndex, chunkText, previousChunkText)
        );
        const batchResults = await Promise.allSettled(batchPromises);

        // Process batch results
        for (let index = 0; index < batchResults.length; index++) {
          completedChunks++;
          const result = batchResults[index];
          const { book, chunkIndex } = batch[index];

          if (result.status === 'fulfilled' && result.value.success) {
            // Convert character names to enum values using mapping
            const conversionResult = await convertCharacterNames(result.value.data);

            if (conversionResult.success && conversionResult.mapping) {
              const updatedData = applyCharacterMapping(result.value.data, conversionResult.mapping);
              allResults.push(updatedData);
            } else {
              // If conversion fails, use original data and log warning
              console.warn(`Character conversion failed for book ${book}, chunk ${chunkIndex}: ${conversionResult.error}`);
              allResults.push(result.value.data);
            }
          } else {
            const errorMessage = result.status === 'fulfilled'
              ? result.value.error
              : result.reason?.message || 'Unknown error';
            failedChunks.push({ book, chunkIndex, error: errorMessage });
            console.error(`Failed to process book ${book}, chunk ${chunkIndex}: ${errorMessage}`);
          }
        }

        updateProgress(`Completed ${completedChunks}/${totalChunks} chunks...`);

        // Small delay between batches to be respectful to the API
        if (i + batchSize < allChunkRequests.length) {
          await new Promise(r => setTimeout(r, 1000));
        }
      }

      // Retry failed chunks one by one
      let retriedChunks = [];
      let remainingFailures = [];

      if (failedChunks.length > 0) {
        updateProgress(`Retrying ${failedChunks.length} failed chunks one by one...`);

        for (let i = 0; i < failedChunks.length; i++) {
          const { book, chunkIndex } = failedChunks[i];
          const originalChunk = allChunkRequests.find(req =>
            req.book === book && req.chunkIndex === chunkIndex
          );

          if (!originalChunk) {
            console.error(`Could not find original chunk data for book ${book}, chunk ${chunkIndex}`);
            remainingFailures.push(failedChunks[i]);
            continue;
          }

          updateProgress(`Retrying ${i + 1}/${failedChunks.length}: Book ${book}, Chunk ${chunkIndex}...`);

          try {
            const retryResult = await makeApiCall(book, chunkIndex, originalChunk.chunkText, originalChunk.previousChunkText);

            if (retryResult.success) {
              // Convert character names to enum values using mapping
              const conversionResult = await convertCharacterNames(retryResult.data);

              if (conversionResult.success && conversionResult.mapping) {
                const updatedData = applyCharacterMapping(retryResult.data, conversionResult.mapping);
                allResults.push(updatedData);
                retriedChunks.push({ book, chunkIndex });
              } else {
                // If conversion fails, use original data and log warning
                console.warn(`Character conversion failed for retry of book ${book}, chunk ${chunkIndex}: ${conversionResult.error}`);
                allResults.push(retryResult.data);
                retriedChunks.push({ book, chunkIndex });
              }
              updateProgress(`✅ Retry successful: Book ${book}, Chunk ${chunkIndex}`);
            } else {
              remainingFailures.push({ book, chunkIndex, error: retryResult.error });
              updateProgress(`❌ Retry failed: Book ${book}, Chunk ${chunkIndex} - ${retryResult.error}`);
            }
          } catch (error) {
            remainingFailures.push({ book, chunkIndex, error: error.message });
            updateProgress(`❌ Retry failed: Book ${book}, Chunk ${chunkIndex} - ${error.message}`);
          }

          // Add a small delay between retry attempts
          if (i < failedChunks.length - 1) {
            await new Promise(r => setTimeout(r, 2000));
          }
        }
      }

      // Group remaining failed chunks by book for summary
      const remainingFailedByBook = {};
      remainingFailures.forEach(({ book, chunkIndex, error }) => {
        if (!remainingFailedByBook[book]) {
          remainingFailedByBook[book] = [];
        }
        remainingFailedByBook[book].push({ chunkIndex, error });
      });

      // Group successfully retried chunks by book
      const retriedByBook = {};
      retriedChunks.forEach(({ book, chunkIndex }) => {
        if (!retriedByBook[book]) {
          retriedByBook[book] = [];
        }
        retriedByBook[book].push(chunkIndex);
      });

      return {
        results: allResults,
        failed: remainingFailedByBook,
        totalFailed: remainingFailures.length,
        totalSuccess: allResults.length,
        retriedSuccess: retriedChunks.length,
        retriedByBook: retriedByBook,
        originalFailures: failedChunks.length
      };
    }

    document.getElementById("startBtn").addEventListener("click", async () => {
      const progressEl = document.getElementById("progress");
      const outputEl = document.getElementById("output");
      const apiKey = getApiKey();

      // Validate inputs
      if (!apiKey) {
        progressEl.textContent = "❌ Please enter your OpenAI API key before starting extraction.";
        progressEl.style.color = "red";
        return;
      }

      if (!apiKey.startsWith('sk-')) {
        progressEl.textContent = "❌ Invalid API key format. OpenAI API keys start with 'sk-'.";
        progressEl.style.color = "red";
        return;
      }

      const fileInput = document.getElementById('bookFiles');
      if (fileInput.files.length === 0) {
        progressEl.textContent = "❌ Please select book files before starting extraction.";
        progressEl.style.color = "red";
        return;
      }

      // Reset progress color
      progressEl.style.color = "";
      progressEl.textContent = "Starting extraction...";

      try {
        const extractionResults = await extractInsults(msg => {
          progressEl.textContent = msg;
        });

        // Create summary message with retry information
        let summary = `Done! Successfully processed ${extractionResults.totalSuccess} chunks.`;
        if (extractionResults.originalFailures > 0) {
          summary += ` Originally ${extractionResults.originalFailures} chunks failed.`;
          if (extractionResults.retriedSuccess > 0) {
            summary += ` Successfully retried ${extractionResults.retriedSuccess} chunks.`;
          }
          if (extractionResults.totalFailed > 0) {
            summary += ` ${extractionResults.totalFailed} chunks remain failed after retry.`;
          } else {
            summary += ` All failed chunks were successfully retried!`;
          }
        }
        progressEl.textContent = summary;

        // Prepare output with results and retry summary
        let output = {
          successful_chunks: extractionResults.results,
          summary: {
            total_chunks: extractionResults.totalSuccess + extractionResults.totalFailed,
            successful: extractionResults.totalSuccess,
            original_failures: extractionResults.originalFailures,
            retried_successes: extractionResults.retriedSuccess,
            remaining_failures: extractionResults.totalFailed
          }
        };

        // Add retry success summary if there were successful retries
        if (extractionResults.retriedSuccess > 0) {
          output.successfully_retried_chunks_by_book = {};
          Object.entries(extractionResults.retriedByBook).forEach(([book, chunkIndexes]) => {
            output.successfully_retried_chunks_by_book[`Book ${book}`] = {
              retried_count: chunkIndexes.length,
              chunk_indexes: chunkIndexes
            };
          });
        }

        // Add remaining failed chunks summary if there are any remaining failures
        if (extractionResults.totalFailed > 0) {
          output.remaining_failed_chunks_by_book = {};
          Object.entries(extractionResults.failed).forEach(([book, chunks]) => {
            output.remaining_failed_chunks_by_book[`Book ${book}`] = {
              failed_count: chunks.length,
              chunks: chunks.map(ch => `Chunk ${ch.chunkIndex}: ${ch.error}`)
            };
          });
        }

        outputEl.textContent = JSON.stringify(output, null, 2);
      } catch (error) {
        progressEl.textContent = `❌ Error: ${error.message}`;
        progressEl.style.color = "red";
        console.error('Extraction error:', error);
      }
    });
  </script>
</body>
</html>
